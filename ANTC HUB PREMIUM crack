--[[ WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk! ]]

local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

local Players           = game:GetService("Players")
local LocalPlayer       = Players.LocalPlayer
local Camera            = workspace.CurrentCamera
local RunService        = game:GetService("RunService")
local UserInputService  = game:GetService("UserInputService")
local UIS               = UserInputService
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local camCFrame = Camera.CFrame

-- ====== DISCORD / WELCOME ======

local discordInvite = ""
setclipboard(discordInvite)

Rayfield:Notify({
    Title = "Discord Invite",
    Content = "Link copied to clipboard!",
    Duration = 5,
    Image = 4483362458,
    Actions = {
        Ignore = {
            Name = "OK",
            Callback = function()
                print("Notification dismissed")
            end
        }
    }
})

Rayfield:Notify({
    Title = "Welcome!",
    Content = "Thanks for using my script! This script was made by a 15-year-old child. Enjoy!",
    Duration = 10,
    Image = 4483362458,
})

-- ====== TIMER NOTIFICATIONS ======

task.spawn(function()
    task.wait(600)
    Rayfield:Notify({
        Title = "Loyalty Check!",
        Content = "Wow, you have been using our script for more than 10 minutes!",
        Duration = 10,
        Image = 4483362458,
    })
end)

task.spawn(function()
    while task.wait(3000) do
        Rayfield:Notify({
            Title = "Support Us!",
            Content = "Follow Instagram @apipajalahh to get a Permanent Key!",
            Duration = 10,
            Image = 4483362458,
        })
    end
end)

local Window = Rayfield:CreateWindow({
    Name = "ANTC HUB PREMIUM",
    LoadingTitle = "ANTC HUB PREMIUM thank you for using the script",
    LoadingSubtitle = "by ANTC HUB team",
    ShowText = "ANTC HUB PREMIUM",
    Theme = "Default",
    ToggleUIKeybind = "K",
    ConfigurationSaving = {
        Enabled = true,
        FileName = "ANTC HUB PREMIUM"
    },
    Discord = {
        Enabled = true,
        Invite = "AEfrtdMz",
        RememberJoins = true
    }
})

-- ====== TABS ======

local AimTab    = Window:CreateTab("Aimbot")
local SilentTab = Window:CreateTab("Silent Aim")
local GunTab    = Window:CreateTab("Gun Mods")
local ESPTab    = Window:CreateTab("ESP")
local ColorTab  = Window:CreateTab("ESP Colors")
local Tab       = Window:CreateTab("LocalPlayer")

-- ====== AIMBOT ======

local AimBotEnabled       = false
local AimKeyHeld          = false
local AimKey              = Enum.KeyCode.Q
local MaxDistance         = 1000
local AimFOV              = 50
local AimSmoothness       = 0.2
local ShowFOV             = true
local VisibleCheckEnabled = true
local AimPart             = "Head"
local PredictionEnabled   = false
local PredictionAmount    = 0.1
local FOVColor            = Color3.fromRGB(255,255,255)

local function createFOVCircle(size, color)
    local gui = LocalPlayer:WaitForChild("PlayerGui"):FindFirstChild("AimbotFOV")
    if not gui then
        gui = Instance.new("ScreenGui")
        gui.Name = "AimbotFOV"
        gui.ResetOnSpawn = false
        gui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    end

    local existing = gui:FindFirstChild("FOVCircle")
    if existing then existing:Destroy() end

    local frame = Instance.new("Frame")
    frame.Name = "FOVCircle"
    frame.Parent = gui
    frame.AnchorPoint = Vector2.new(0.5,0.5)
    frame.Position = UDim2.new(0.5,0,0.5,0)
    frame.Size = UDim2.new(0,size*2,0,size*2)
    frame.BackgroundTransparency = 1
    frame.BorderSizePixel = 0
    frame.Visible = ShowFOV

    local stroke = Instance.new("UIStroke")
    stroke.Parent = frame
    stroke.Color = color
    stroke.Thickness = 2

    local corner = Instance.new("UICorner")
    corner.Parent = frame
    corner.CornerRadius = UDim.new(1,0)

    return frame, stroke
end

local AimbotFOVCircle, AimbotFOVStroke = createFOVCircle(AimFOV, FOVColor)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == AimKey then
        AimKeyHeld = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == AimKey then
        AimKeyHeld = false
    end
end)

local function isInAimbotFOV(worldPos)
    local mousePos = UserInputService:GetMouseLocation()
    local screenPos, onScreen = Camera:WorldToViewportPoint(worldPos)
    if not onScreen then return false end
    local dist = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(mousePos.X, mousePos.Y)).Magnitude
    return dist <= AimFOV
end

local function isVisibleAimbot(part)
    local origin    = Camera.CFrame.Position
    local direction = (part.Position - origin)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local result = workspace:Raycast(origin, direction, rayParams)
    if result then
        return result.Instance:IsDescendantOf(part.Parent)
    end
    return true
end

local function applyAimbotPrediction(part)
    if PredictionEnabled and part.Parent:FindFirstChild("HumanoidRootPart") then
        local velocity = part.Parent.HumanoidRootPart.Velocity
        return part.Position + velocity * PredictionAmount
    end
    return part.Position
end

local function getNearestPlayerPart()
    local best, bestDist = nil, math.huge
    for _, pl in pairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChild(AimPart) then
            local part = pl.Character[AimPart]
            local dist = (part.Position - Camera.CFrame.Position).Magnitude
            local visible = true
            if VisibleCheckEnabled then
                visible = isVisibleAimbot(part)
            end
            if dist <= MaxDistance and dist < bestDist and isInAimbotFOV(part.Position) and visible then
                best = part
                bestDist = dist
            end
        end
    end
    return best
end

AimTab:CreateToggle({
    Name = "Enable Aimbot",
    CurrentValue = AimBotEnabled,
    Callback = function(val) AimBotEnabled = val end
})

AimTab:CreateKeybind({
    Name = "Aim Key",
    CurrentKeybind = AimKey.Name,
    HoldToInteract = true,
    Callback = function(isHeld) AimKeyHeld = isHeld end
})

AimTab:CreateSlider({
    Name = "FOV Size",
    Range = {0,200},
    Increment = 5,
    CurrentValue = AimFOV,
    Callback = function(val)
        AimFOV = val
        if AimbotFOVCircle then
            AimbotFOVCircle.Size = UDim2.new(0,val*2,0,val*2)
        end
    end
})

AimTab:CreateSlider({
    Name = "Max Distance",
    Range = {0,2000},
    Increment = 50,
    CurrentValue = MaxDistance,
    Callback = function(val) MaxDistance = val end
})

AimTab:CreateSlider({
    Name = "Smoothness",
    Range = {0,1},
    Increment = 0.05,
    CurrentValue = AimSmoothness,
    Callback = function(val) AimSmoothness = val end
})

AimTab:CreateSlider({
    Name = "Prediction Amount",
    Range = {0,1},
    Increment = 0.01,
    CurrentValue = PredictionAmount,
    Callback = function(val) PredictionAmount = val end
})

AimTab:CreateToggle({
    Name = "Show FOV",
    CurrentValue = ShowFOV,
    Callback = function(val)
        ShowFOV = val
        if AimbotFOVCircle then AimbotFOVCircle.Visible = val end
    end
})

AimTab:CreateToggle({
    Name = "Visible Check",
    CurrentValue = VisibleCheckEnabled,
    Callback = function(val) VisibleCheckEnabled = val end
})

AimTab:CreateToggle({
    Name = "Prediction",
    CurrentValue = PredictionEnabled,
    Callback = function(val) PredictionEnabled = val end
})

AimTab:CreateDropdown({
    Name = "Aim Body Part",
    Options = {"Head","UpperTorso","LowerTorso","HumanoidRootPart"},
    CurrentOption = {AimPart},
    Callback = function(opt) AimPart = opt[1] end
})

RunService.RenderStepped:Connect(function()
    if AimbotFOVCircle then
        AimbotFOVCircle.Position = UDim2.new(0.5,0,0.5,0)
    end
    if AimBotEnabled and AimKeyHeld then
        local target = getNearestPlayerPart()
        if target then
            local targetPos     = applyAimbotPrediction(target)
            local currentCFrame = Camera.CFrame
            local targetCFrame  = CFrame.lookAt(currentCFrame.Position, targetPos)
            Camera.CFrame = currentCFrame:Lerp(targetCFrame, AimSmoothness)
        end
    end
end)

-- ====== SILENT AIM ======

local SilentSettings = {
    Enable            = false,
    FOV               = 150,
    HitChance         = 1,
    Delay             = 0.1,
    LifeCheck         = true,
    VisibleCheck      = true,
    ShootThroughWalls = false,
    ShowFOV           = true,
    PredictionEnabled = true,
    PredictionAmount  = 0.2
}
local lastShot = 0

local SilentFOVGui = Instance.new("ScreenGui")
SilentFOVGui.Name = "SilentFOVGui"
SilentFOVGui.ResetOnSpawn = false
SilentFOVGui.DisplayOrder = 999
SilentFOVGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local SilentFOVCircle = Instance.new("Frame")
SilentFOVCircle.AnchorPoint = Vector2.new(0.5,0.5)
SilentFOVCircle.Position = UDim2.new(0.5,0,0.5,0)
SilentFOVCircle.Size = UDim2.new(0, SilentSettings.FOV*2, 0, SilentSettings.FOV*2)
SilentFOVCircle.BackgroundTransparency = 1
SilentFOVCircle.BorderSizePixel = 0
SilentFOVCircle.Visible = SilentSettings.ShowFOV
SilentFOVCircle.Parent = SilentFOVGui

local SilentStroke = Instance.new("UIStroke")
SilentStroke.Parent = SilentFOVCircle
SilentStroke.Color = Color3.fromRGB(255,255,255)
SilentStroke.Thickness = 2

local SilentCorner = Instance.new("UICorner")
SilentCorner.Parent = SilentFOVCircle
SilentCorner.CornerRadius = UDim.new(1,0)

local function isInSilentFOV(worldPos)
    local mousePos = UserInputService:GetMouseLocation()
    local screenPos, onScreen = Camera:WorldToViewportPoint(worldPos)
    if not onScreen then return false end
    local dist = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(mousePos.X, mousePos.Y)).Magnitude
    return dist <= SilentSettings.FOV
end

local function isVisibleSilent(part)
    local origin    = Camera.CFrame.Position
    local direction = (part.Position - origin)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local result = workspace:Raycast(origin, direction, rayParams)
    return (not result) or result.Instance:IsDescendantOf(part.Parent)
end

local function applySilentPrediction(part)
    if SilentSettings.PredictionEnabled and part.Parent:FindFirstChild("HumanoidRootPart") then
        return part.Position + part.Parent.HumanoidRootPart.Velocity * SilentSettings.PredictionAmount
    end
    return part.Position
end

RunService.RenderStepped:Connect(function(dt)
    if not SilentSettings.Enable then
        SilentStroke.Color = Color3.fromRGB(255,255,255)
        return
    end

    lastShot = lastShot + dt
    local closest, closestDist = nil, SilentSettings.FOV
    local screenCenter = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

    for _, p in pairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = p.Character.HumanoidRootPart
            local humanoid = p.Character:FindFirstChildOfClass("Humanoid")

            if humanoid and (not SilentSettings.LifeCheck or humanoid.Health > 0) then
                local screenPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
                if onScreen then
                    local delta = (Vector2.new(screenPos.X,screenPos.Y)-screenCenter).Magnitude
                    if delta <= closestDist and isInSilentFOV(hrp.Position) then
                        if SilentSettings.ShootThroughWalls
                        or (not SilentSettings.ShootThroughWalls and (not SilentSettings.VisibleCheck or isVisibleSilent(hrp))) then
                            closest = p
                            closestDist = delta
                        end
                    end
                end
            end
        end
    end

    if closest then
        SilentStroke.Color = Color3.fromRGB(0,255,0)
    else
        SilentStroke.Color = Color3.fromRGB(255,255,255)
    end

    if closest and lastShot >= SilentSettings.Delay and math.random() <= SilentSettings.HitChance then
        local weapon = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
        local bnl    = ReplicatedStorage:FindFirstChild("Bnl")
        local event  = bnl and bnl:FindFirstChild("635831fc-aa69-408c-a888-190900cf67b3")
        if weapon and event and weapon:FindFirstChild("Handle") then
            local hrp = closest.Character.HumanoidRootPart
            local pos = applySilentPrediction(hrp)
            event:FireServer(weapon, pos, (pos - weapon.Handle.Position).Unit)
            lastShot = 0
        end
    end
end)

SilentTab:CreateToggle({
    Name = "Enable Silent Aim",
    CurrentValue = SilentSettings.Enable,
    Callback = function(v) SilentSettings.Enable = v end
})
SilentTab:CreateToggle({
    Name = "Life Check",
    CurrentValue = SilentSettings.LifeCheck,
    Callback = function(v) SilentSettings.LifeCheck = v end
})
SilentTab:CreateToggle({
    Name = "Visible Check",
    CurrentValue = SilentSettings.VisibleCheck,
    Callback = function(v) SilentSettings.VisibleCheck = v end
})
SilentTab:CreateToggle({
    Name = "Shoot Through Walls",
    CurrentValue = SilentSettings.ShootThroughWalls,
    Callback = function(v) SilentSettings.ShootThroughWalls = v end
})
SilentTab:CreateToggle({
    Name = "Show FOV",
    CurrentValue = SilentSettings.ShowFOV,
    Callback = function(v)
        SilentSettings.ShowFOV = v
        SilentFOVCircle.Visible = v
    end
})
SilentTab:CreateSlider({
    Name = "FOV",
    Range = {50,500},
    Increment = 1,
    CurrentValue = SilentSettings.FOV,
    Callback = function(v)
        SilentSettings.FOV = v
        SilentFOVCircle.Size = UDim2.new(0,v*2,0,v*2)
    end
})
SilentTab:CreateSlider({
    Name = "HitChance",
    Range = {0,1},
    Increment = 0.01,
    CurrentValue = SilentSettings.HitChance,
    Callback = function(v) SilentSettings.HitChance = v end
})
SilentTab:CreateSlider({
    Name = "Delay",
    Range = {0,1},
    Increment = 0.01,
    CurrentValue = SilentSettings.Delay,
    Callback = function(v) SilentSettings.Delay = v end
})
SilentTab:CreateToggle({
    Name = "Prediction",
    CurrentValue = SilentSettings.PredictionEnabled,
    Callback = function(v) SilentSettings.PredictionEnabled = v end
})
SilentTab:CreateSlider({
    Name = "Prediction Amount",
    Range = {0,1},
    Increment = 0.01,
    CurrentValue = SilentSettings.PredictionAmount,
    Callback = function(v) SilentSettings.PredictionAmount = v end
})

-- ====== GUN MODS ======

local rapidEnabled, rapidValue = false, 0
local noReloadEnabled, noRecoilEnabled = false, false
local CrosshairSizeEnabled, AimDelayEnabled = false, false

GunTab:CreateToggle({
    Name = "RapidFire",
    CurrentValue = false,
    Callback = function(v) rapidEnabled = v end
})
GunTab:CreateSlider({
    Name = "RapidFire Delay",
    Range = {0,1},
    Increment = 0.01,
    CurrentValue = 0,
    Callback = function(v) rapidValue = v end
})
GunTab:CreateToggle({
    Name = "No Reload",
    CurrentValue = false,
    Callback = function(v) noReloadEnabled = v end
})
GunTab:CreateToggle({
    Name = "No Recoil",
    CurrentValue = false,
    Callback = function(v) noRecoilEnabled = v end
})
GunTab:CreateToggle({
    Name = "CrosshairSize",
    CurrentValue = false,
    Callback = function(v) CrosshairSizeEnabled = v end
})
GunTab:CreateToggle({
    Name = "AimDelay",
    CurrentValue = false,
    Callback = function(v) AimDelayEnabled = v end
})

task.spawn(function()
    while task.wait(0.2) do
        local char = LocalPlayer.Character
        if char then
            local tool = char:FindFirstChildOfClass("Tool")
            if tool then
                if rapidEnabled and tool:GetAttribute("ShootDelay")    then tool:SetAttribute("ShootDelay", rapidValue) end
                if noReloadEnabled and tool:GetAttribute("ReloadTime") then tool:SetAttribute("ReloadTime", 0)         end
                if noRecoilEnabled and tool:GetAttribute("Recoil")     then tool:SetAttribute("Recoil", 0)             end
                if CrosshairSizeEnabled and tool:GetAttribute("CrosshairSize") then tool:SetAttribute("CrosshairSize", 0) end
                if AimDelayEnabled and tool:GetAttribute("AimDelay")   then tool:SetAttribute("AimDelay", 0)           end
            end
        end
    end
end)

-- ====== INF STAMINA ======

Tab:CreateButton({
   Name = "Inf Stamina",
   Callback = function()
      local Module      = LocalPlayer.PlayerScripts.Code.controllers.character.characterStaminaController
      local ClassModule = require(Module).CharacterStaminaController
      hookfunction(ClassModule.useStamina, function()
         return true
      end)
   end,
})

-- ====== INFINITY JUMP ======

_G.InfinityJumpEnabled = false

Tab:CreateToggle({
    Name = "Infinity Jump you can be kicked",
    CurrentValue = false,
    Flag = "InfinityJumpToggle",
    Callback = function(Value)
        _G.InfinityJumpEnabled = Value
    end,
})

UIS.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and _G.InfinityJumpEnabled and input.KeyCode == Enum.KeyCode.Space then
        local character = LocalPlayer.Character
        if character and character:FindFirstChildOfClass("Humanoid") then
            character:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)

-- ====== GHOST MODE ======

_G.GhostEnabled = false
_G.GhostColor   = Color3.fromRGB(200,200,255)

Tab:CreateToggle({
    Name = "Ghost Mode just cosmetics",
    CurrentValue = false,
    Flag = "GhostToggle",
    Callback = function(Value)
        _G.GhostEnabled = Value
        local character = LocalPlayer.Character
        if character then
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    if Value then
                        part.Transparency = 0.6
                        local highlight = Instance.new("Highlight")
                        highlight.Name = "GhostHighlight"
                        highlight.FillTransparency = 1
                        highlight.OutlineTransparency = 0
                        highlight.OutlineColor = _G.GhostColor or Color3.fromRGB(200,200,255)
                        highlight.Parent = part

                        local p = Instance.new("ParticleEmitter")
                        p.Name = "GhostParticles"
                        p.Texture = "rbxassetid://258128463"
                        p.Rate = 5
                        p.Lifetime = NumberRange.new(1,2)
                        p.Size = NumberSequence.new(0.5)
                        p.Transparency = NumberSequence.new({
                            NumberSequenceKeypoint.new(0,0.6),
                            NumberSequenceKeypoint.new(1,1)
                        })
                        p.Color = ColorSequence.new(_G.GhostColor or Color3.fromRGB(200,200,255))
                        p.Parent = part
                    else
                        part.Transparency = 0
                        if part:FindFirstChild("GhostHighlight") then part.GhostHighlight:Destroy() end
                        if part:FindFirstChild("GhostParticles") then part.GhostParticles:Destroy() end
                    end
                end
            end
        end
    end,
})

Tab:CreateColorPicker({
    Name = "Ghost Color",
    Color = Color3.fromRGB(200,200,255),
    Callback = function(value)
        _G.GhostColor = value
        local char = LocalPlayer.Character
        if char then
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    if part:FindFirstChild("GhostHighlight") then
                        part.GhostHighlight.OutlineColor = value
                    end
                    if part:FindFirstChild("GhostParticles") then
                        part.GhostParticles.Color = ColorSequence.new(value)
                    end
                end
            end
        end
    end,
})

-- ====== TRAIL (COSMETIC) ======

_G.TrailEnabled      = false
_G.TrailLifetime     = 2
_G.TrailTransparency = 0.5
_G.TrailColor        = Color3.fromRGB(200,200,255)

Tab:CreateToggle({
    Name = "Trail just cosmetics",
    CurrentValue = false,
    Flag = "TrailToggle",
    Callback = function(Value)
        _G.TrailEnabled = Value
        local character = LocalPlayer.Character
        if character then
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then
                if Value then
                    local attachment0 = Instance.new("Attachment")
                    attachment0.Name = "TrailAttachment0"
                    attachment0.Position = Vector3.new(0, 0.5, 0)
                    attachment0.Parent = hrp

                    local attachment1 = Instance.new("Attachment")
                    attachment1.Name = "TrailAttachment1"
                    attachment1.Position = Vector3.new(0, -0.5, 0)
                    attachment1.Parent = hrp

                    local trail = Instance.new("Trail")
                    trail.Name = "GhostTrail"
                    trail.Attachment0 = attachment0
                    trail.Attachment1 = attachment1
                    trail.Color = ColorSequence.new(_G.TrailColor or Color3.fromRGB(200,200,255))
                    trail.Lifetime = _G.TrailLifetime or 2
                    trail.Transparency = NumberSequence.new(_G.TrailTransparency or 0.5)
                    trail.MinLength = 0.1
                    trail.LightEmission = 0.7
                    trail.Enabled = true
                    trail.Parent = hrp
                else
                    for _, obj in ipairs(hrp:GetChildren()) do
                        if obj.Name == "TrailAttachment0" or obj.Name == "TrailAttachment1" or obj.Name == "GhostTrail" then
                            obj:Destroy()
                        end
                    end
                end
            end
        end
    end,
})

Tab:CreateSlider({
    Name = "Trail Lifetime",
    Range = {1, 10},
    Increment = 1,
    Suffix = "s",
    CurrentValue = _G.TrailLifetime or 2,
    Flag = "TrailLifetime",
    Callback = function(Value)
        _G.TrailLifetime = Value
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local trail = hrp:FindFirstChild("GhostTrail")
            if trail then
                trail.Lifetime = Value
            end
        end
    end,
})

Tab:CreateSlider({
    Name = "Trail Transparency",
    Range = {0, 1},
    Increment = 0.05,
    CurrentValue = _G.TrailTransparency or 0.5,
    Flag = "TrailTransparency",
    Callback = function(Value)
        _G.TrailTransparency = Value
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local trail = hrp:FindFirstChild("GhostTrail")
            if trail then
                trail.Transparency = NumberSequence.new(Value)
            end
        end
    end,
})

Tab:CreateColorPicker({
    Name = "Trail Color",
    Color = Color3.fromRGB(200,200,255),
    Callback = function(value)
        _G.TrailColor = value
        local char = LocalPlayer.Character
        if char then
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if hrp and hrp:FindFirstChild("GhostTrail") then
                hrp.GhostTrail.Color = ColorSequence.new(value)
            end
        end
    end,
})

-- ====== SPEEDHACK ======

_G.SpeedEnabled = false
_G.Speed        = 32

Tab:CreateSlider({
    Name = "Speed",
    Range = {16, 100},
    Increment = 1,
    CurrentValue = 32,
    Flag = "SpeedSlider",
    Callback = function(Value)
        _G.Speed = Value
    end,
})

Tab:CreateToggle({
    Name = "Enable SpeedHack you can be kicked",
    CurrentValue = false,
    Flag = "SpeedToggle",
    Callback = function(Value)
        _G.SpeedEnabled = Value
    end,
})

local speedMoveInput = {W=false, A=false, S=false, D=false}

UIS.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.W then speedMoveInput.W = true end
    if input.KeyCode == Enum.KeyCode.A then speedMoveInput.A = true end
    if input.KeyCode == Enum.KeyCode.S then speedMoveInput.S = true end
    if input.KeyCode == Enum.KeyCode.D then speedMoveInput.D = true end
end)

UIS.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.W then speedMoveInput.W = false end
    if input.KeyCode == Enum.KeyCode.A then speedMoveInput.A = false end
    if input.KeyCode == Enum.KeyCode.S then speedMoveInput.S = false end
    if input.KeyCode == Enum.KeyCode.D then speedMoveInput.D = false end
end)

task.spawn(function()
    while true do
        if _G.SpeedEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = LocalPlayer.Character.HumanoidRootPart
            local camCFrame = Camera.CFrame
            local lookVector = Vector3.new(camCFrame.LookVector.X, 0, camCFrame.LookVector.Z).Unit
            local rightVector = Vector3.new(camCFrame.RightVector.X, 0, camCFrame.RightVector.Z).Unit

            local dir = Vector3.new(0,0,0)
            if speedMoveInput.W then dir = dir + lookVector end
            if speedMoveInput.S then dir = dir - lookVector end
            if speedMoveInput.A then dir = dir - rightVector end
            if speedMoveInput.D then dir = dir + rightVector end

            if dir.Magnitude > 0 then
                dir = dir.Unit * _G.Speed * 0.03
                hrp.CFrame = CFrame.new(hrp.Position + Vector3.new(dir.X, 0, dir.Z))
            end
        end
        task.wait(0.03)
    end
end)

-- ====== FLY ======

_G.FlyEnabled = false
_G.FlySpeed   = 32

local function getCharacter()
    return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
end

Tab:CreateToggle({
    Name = "Fly you can be kicked",
    CurrentValue = false,
    Flag = "FlyToggle",
    Callback = function(Value)
        _G.FlyEnabled = Value
        local character = getCharacter()
        local hum = character:FindFirstChildOfClass("Humanoid")
        if hum then
            hum.PlatformStand = Value
        end
    end,
})

Tab:CreateSlider({
    Name = "Fly Speed",
    Range = {16, 100},
    Increment = 1,
    CurrentValue = 32,
    Flag = "FlySpeedSlider",
    Callback = function(Value)
        _G.FlySpeed = Value
    end,
})

local flyMoveInput = {W=false, A=false, S=false, D=false, Up=false, Down=false}

UIS.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.W then flyMoveInput.W = true end
    if input.KeyCode == Enum.KeyCode.A then flyMoveInput.A = true end
    if input.KeyCode == Enum.KeyCode.S then flyMoveInput.S = true end
    if input.KeyCode == Enum.KeyCode.D then flyMoveInput.D = true end
    if input.KeyCode == Enum.KeyCode.Space then flyMoveInput.Up = true end
    if input.KeyCode == Enum.KeyCode.LeftShift then flyMoveInput.Down = true end
end)

UIS.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.W then flyMoveInput.W = false end
    if input.KeyCode == Enum.KeyCode.A then flyMoveInput.A = false end
    if input.KeyCode == Enum.KeyCode.S then flyMoveInput.S = false end
    if input.KeyCode == Enum.KeyCode.D then flyMoveInput.D = false end
    if input.KeyCode == Enum.KeyCode.Space then flyMoveInput.Up = false end
    if input.KeyCode == Enum.KeyCode.LeftShift then flyMoveInput.Down = false end
end)

task.spawn(function()
    while true do
        if _G.FlyEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = LocalPlayer.Character.HumanoidRootPart
            local camCFrame = Camera.CFrame
            local dir = Vector3.new(0,0,0)

            if flyMoveInput.W then dir = dir + camCFrame.LookVector end
            if flyMoveInput.S then dir = dir - camCFrame.LookVector end
            if flyMoveInput.A then dir = dir - camCFrame.RightVector end
            if flyMoveInput.D then dir = dir + camCFrame.RightVector end
            if flyMoveInput.Up then dir = dir + Vector3.new(0,1,0) end
            if flyMoveInput.Down then dir = dir - Vector3.new(0,1,0) end

            if dir.Magnitude > 0 then
                hrp.CFrame = CFrame.new(
                    hrp.Position + dir.Unit * (_G.FlySpeed * 0.03),
                    hrp.Position + camCFrame.LookVector
                )
            else
                hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + camCFrame.LookVector)
            end

            hrp.AssemblyLinearVelocity = Vector3.zero
            hrp.AssemblyAngularVelocity = Vector3.zero
        end
        task.wait(0.03)
    end
end)

-- ====== ESP ======

local Settings = {
    MaxDistance   = 800,
    NameESP       = true,
    DistanceESP   = true,
    ItemESP       = true,
    LineESP       = false,
    HealthbarESP  = true,
    SkeletonESP   = false,
    TeamESP       = true,
    ESPEnabled    = true
}

local Colors = {
    Name      = Color3.fromRGB(255,255,255),
    Distance  = Color3.fromRGB(200,200,200),
    Item      = Color3.fromRGB(150,200,255),
    Line      = Color3.fromRGB(120,220,220),
    Healthbar = Color3.fromRGB(0,255,0),
    Skeleton  = Color3.fromRGB(255,0,0),
    Wanted    = Color3.fromRGB(255,50,50)
}

local TEAM_COLORS = {
    ADAC          = Color3.fromRGB(255, 255, 0),
    BusCompany    = Color3.fromRGB(0, 200, 255),
    Citizen       = Color3.fromRGB(255, 255, 255),
    FireDepartment= Color3.fromRGB(255, 100, 0),
    Police        = Color3.fromRGB(0, 0, 255),
    Prisoner      = Color3.fromRGB(255, 0, 0),
    TruckCompany  = Color3.fromRGB(0, 255, 0),
}

local DrawCache = {}

local function newText()
    local t = Drawing.new("Text")
    t.Size = 16
    t.Center = true
    t.Outline = true
    t.Font = 2
    t.Visible = false
    return t
end

local function newLine()
    local l = Drawing.new("Line")
    l.Thickness = 2
    l.Visible = false
    return l
end

local function ensureDrawings(player)
    if DrawCache[player] then return DrawCache[player] end
    local t = {
        NameText    = newText(),
        DistanceText= newText(),
        ItemText    = newText(),
        Line        = newLine(),
        HealthBG    = newLine(),
        Health      = newLine(),
        Skeleton    = {}
    }
    DrawCache[player] = t
    return t
end

local function cleanupDrawings(player)
    local t = DrawCache[player]
    if not t then return end
    for _, v in pairs(t) do
        if type(v) == "table" then
            for _, l in ipairs(v) do
                if l and l.Remove then l:Remove() end
            end
        elseif v.Remove then
            v:Remove()
        end
    end
    DrawCache[player] = nil
end

Players.PlayerRemoving:Connect(cleanupDrawings)

local function getTeamLabelAndColor(player)
    local team = player and player.Team
    if Settings.TeamESP and team and TEAM_COLORS[team.Name] then
        return team.Name, TEAM_COLORS[team.Name]
    end
    return nil, Colors.Name
end

local function healthColorFromPercent(p)
    p = math.clamp(p,0,1)
    return Color3.new(1-p, p, 0)
end

local function getSkeletonConns(char)
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum then return {} end
    if hum.RigType == Enum.HumanoidRigType.R15 then
        return {
            {"Head","UpperTorso"},{"UpperTorso","LowerTorso"},
            {"UpperTorso","LeftUpperArm"},{"LeftUpperArm","LeftLowerArm"},{"LeftLowerArm","LeftHand"},
            {"UpperTorso","RightUpperArm"},{"RightUpperArm","RightLowerArm"},{"RightLowerArm","RightHand"},
            {"LowerTorso","LeftUpperLeg"},{"LeftUpperLeg","LeftLowerLeg"},{"LeftLowerLeg","LeftFoot"},
            {"LowerTorso","RightUpperLeg"},{"RightUpperLeg","RightLowerLeg"},{"RightLowerLeg","RightFoot"}
        }
    else
        return {
            {"Head","Torso"},
            {"Torso","Left Arm"},{"Torso","Right Arm"},
            {"Torso","Left Leg"},{"Torso","Right Leg"}
        }
    end
end

local function createToggle(name, flag)
    ESPTab:CreateToggle({
        Name = name,
        CurrentValue = Settings[name:gsub(" ","")],
        Flag = flag,
        Callback = function(v)
            Settings[name:gsub(" ","")] = v
            if name == "ESP Enabled" and not v then
                for _, player in ipairs(Players:GetPlayers()) do
                    cleanupDrawings(player)
                end
            end
        end
    })
end

for _, name in ipairs({"Name ESP","Distance ESP","Item ESP","Line ESP","Healthbar ESP","Skeleton ESP","Team ESP","ESP Enabled"}) do
    createToggle(name, name.."Flag")
end

ESPTab:CreateSlider({
    Name = "Max ESP Distance",
    Range = {50,5000},
    Increment = 50,
    Suffix = "studs",
    CurrentValue = Settings.MaxDistance,
    Flag = "MaxDistanceFlag",
    Callback = function(v) Settings.MaxDistance = v end
})

for k,v in pairs(Colors) do
    ColorTab:CreateColorPicker({
        Name = k.." Color",
        Color = v,
        Flag = "Color"..k,
        Callback = function(c) Colors[k] = c end
    })
end

RunService.RenderStepped:Connect(function()
    if not Settings.ESPEnabled then return end
    local camPos = Camera.CFrame.Position

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then
            continue
        end
        local char = player.Character
        local hrp  = char and char:FindFirstChild("HumanoidRootPart")
        local hum  = char and char:FindFirstChildOfClass("Humanoid")
        if not hrp or not hum then
            cleanupDrawings(player)
            continue
        end

        local dist = (hrp.Position - camPos).Magnitude
        local sPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
        if dist > Settings.MaxDistance or not onScreen then
            cleanupDrawings(player)
            continue
        end

        local drawings = ensureDrawings(player)
        local teamLabel, teamColor = getTeamLabelAndColor(player)

        local baseY = sPos.Y - 20
        local texts = {}

        if Settings.NameESP then
            local displayName = player.Name
            local color = Colors.Name
            if teamLabel then
                displayName = string.format("%s [%s]", player.Name, teamLabel)
                color = teamColor
            end
            table.insert(texts, {drawings.NameText, displayName, color})
        end

        if Settings.DistanceESP then
            table.insert(texts, {drawings.DistanceText, "["..math.floor(dist).."m]", Colors.Distance})
        end

        if Settings.ItemESP then
            local tool = char:FindFirstChildOfClass("Tool")
            if tool then
                table.insert(texts, {drawings.ItemText, tool.Name, Colors.Item})
            end
        end

        drawings.NameText.Visible = false
        drawings.DistanceText.Visible = false
        drawings.ItemText.Visible = false

        for i, t in ipairs(texts) do
            local obj, txt, col = t[1], t[2], t[3]
            obj.Position = Vector2.new(sPos.X, baseY + (i-1)*20)
            obj.Text     = txt
            obj.Color    = col
            obj.Visible  = true
        end

        drawings.Line.Visible = Settings.LineESP
        if Settings.LineESP then
            drawings.Line.From  = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
            drawings.Line.To    = Vector2.new(sPos.X, sPos.Y)
            drawings.Line.Color = teamColor or Colors.Line
        end

        drawings.Health.Visible   = Settings.HealthbarESP
        drawings.HealthBG.Visible = Settings.HealthbarESP
        if Settings.HealthbarESP then
            local offsetX = 25
            local topV    = Vector2.new(sPos.X + offsetX, sPos.Y - 20)
            local bottomV = Vector2.new(sPos.X + offsetX, sPos.Y + 20)
            drawings.HealthBG.From      = topV
            drawings.HealthBG.To        = bottomV
            drawings.HealthBG.Color     = Color3.fromRGB(0,0,0)
            drawings.HealthBG.Thickness = 3

            local hpPct = hum.Health / hum.MaxHealth
            drawings.Health.From      = bottomV
            drawings.Health.To        = Vector2.new(bottomV.X, bottomV.Y - (40 * hpPct))
            drawings.Health.Color     = teamColor or healthColorFromPercent(hpPct)
            drawings.Health.Thickness = 3
        end

        if Settings.SkeletonESP then
            local conns = getSkeletonConns(char)
            if #drawings.Skeleton < #conns then
                for i = #drawings.Skeleton+1, #conns do
                    table.insert(drawings.Skeleton, newLine())
                end
            end
            for i, pair in ipairs(conns) do
                local partA = char:FindFirstChild(pair[1])
                local partB = char:FindFirstChild(pair[2])
                local ln    = drawings.Skeleton[i]
                if partA and partB then
                    local aScr,_ = Camera:WorldToViewportPoint(partA.Position)
                    local bScr,_ = Camera:WorldToViewportPoint(partB.Position)
                    ln.From   = Vector2.new(aScr.X,aScr.Y)
                    ln.To     = Vector2.new(bScr.X,bScr.Y)
                    ln.Color  = teamColor or Colors.Skeleton
                    ln.Visible= true
                else
                    ln.Visible = false
                end
            end
        else
            for _, ln in ipairs(drawings.Skeleton) do
                if ln then ln.Visible = false end
            end
        end
    end
end)
